import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase';
import { authMiddleware, type AuthResult } from '@/lib/auth';
import { StorySchema, VideoSchema, validateSchema, type Story, type Mulmoscript } from '@/lib/schemas';
import { ErrorType } from '@/types';

// ================================================================
// Route Parameters Type
// ================================================================

interface RouteContext {
  params: Promise<{ id: string }>;
}

// ================================================================
// Types
// ================================================================

interface VideoConfig {
  scenes: any[];
  characters: any[];
  audioSettings: any;
  bgmSettings: any;
  subtitleSettings: any;
}

// ================================================================
// Helper Functions
// ================================================================

function isValidStoryId(id: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return typeof id === 'string' && uuidRegex.test(id);
}

async function getStoryWithAuth(storyId: string, uid: string) {
  const supabase = createAdminClient();

  const { data, error } = await supabase
    .from('stories')
    .select('*')
    .eq('id', storyId)
    .eq('uid', uid)
    .single();

  if (error || !data) {
    throw new Error('Story not found');
  }

  return data;
}

/**
 * Workflow„Éá„Éº„Çø„Åã„ÇâMulmoScriptÂΩ¢Âºè„Å´Â§âÊèõ
 */
function convertToMulmoscript(story: Story, videoConfig: VideoConfig): Mulmoscript {
  const { scenes, characters, audioSettings, bgmSettings, subtitleSettings } = videoConfig;

  // „Çπ„Éî„Éº„Ç´„ÉºÊÉÖÂ†±„ÅÆÊßãÁØâ
  const speakers: Record<string, any> = {};
  characters.forEach((char: any) => {
    speakers[char.id] = {
      voiceId: char.voiceId,
      displayName: {
        ja: char.name,
        en: char.name,
      },
    };
  });

  // „Éì„Éº„ÉàÔºà„Ç∑„Éº„É≥Ôºâ„ÅÆÊßãÁØâ
  const beats = scenes.map((scene: any) => ({
    id: scene.sceneId,
    speaker: scene.speaker,
    text: scene.dialogue,
    description: scene.title,
    imagePrompt: scene.imagePrompt,
    image: scene.customImageUrl ? {
      type: 'image' as const,
      source: {
        kind: 'url' as const,
        url: scene.customImageUrl,
      },
    } : undefined,
  }));

  // BGMË®≠ÂÆö„ÅÆÊßãÁØâ
  const bgmUrl = bgmSettings.find((bgm: any) => bgm.bgmId !== 'bgm_none')?.url;

  return {
    $mulmocast: {
      version: '1.0',
      credit: 'closing',
    },
    title: story.title,
    description: `Generated by ScriptDirector V2`,
    lang: 'ja',
    canvasSize: {
      width: 1280,
      height: 720,
    },
    speechParams: {
      provider: 'openai',
      speakers,
    },
    imageParams: {
      provider: 'openai',
      style: 'anime soft pastel colors',
      quality: process.env.OPENAI_IMAGE_QUALITY_DEFAULT || 'medium',
    },
    audioParams: {
      padding: 0.3,
      introPadding: 1.0,
      closingPadding: 0.8,
      outroPadding: 1.0,
      bgmVolume: audioSettings.masterBGMVolume || 0.2,
      audioVolume: audioSettings.audioVolume || 1.0,
      bgm: bgmUrl ? {
        kind: 'url',
        url: bgmUrl,
      } : undefined,
    },
    captionParams: subtitleSettings.enableSubtitles ? {
      lang: subtitleSettings.subtitleLanguage || 'ja',
      styles: [],
    } : undefined,
    beats,
  };
}

// ================================================================
// POST /api/stories/[id]/workflow/generate-final-video
// ================================================================

export async function POST(
  request: NextRequest,
  context: RouteContext
): Promise<NextResponse> {
  const { id: storyId } = await context.params;

  // Validate story ID
  if (!isValidStoryId(storyId)) {
    return NextResponse.json(
      { error: 'Invalid story ID format' },
      { status: 400 }
    );
  }

  // UID„ÇíÂèñÂæóÔºàgetOrCreateUid„Éò„É´„Éë„Éº„Çí‰ΩøÁî®Ôºâ
  const { getOrCreateUid } = await import('@/lib/uid-server');
  const uid = await getOrCreateUid(request);
  
  if (!uid) {
    return NextResponse.json(
      { error: 'UID not found' },
      { status: 401 }
    );
  }

  console.log(`üé¨ ÂãïÁîªÁîüÊàê„É™„ÇØ„Ç®„Çπ„Éà: Story ${storyId}, UID ${uid}`);

  try {
    // Get request body
    const body = await request.json();
    const videoConfig: VideoConfig = body;

    if (!videoConfig.scenes || !videoConfig.characters) {
      return NextResponse.json(
        { error: 'Video configuration is incomplete' },
        { status: 400 }
      );
    }

    // Get story with ownership check
    const story = await getStoryWithAuth(storyId, uid);

    // Convert to MulmoScript format
    const mulmoscript = convertToMulmoscript(story, videoConfig);

    // Update story with final script
    const supabase = createAdminClient();
    const { error: updateError } = await supabase
      .from('stories')
      .update({
        script_json: mulmoscript,
        status: 'script_generated',
        workflow_state: {
          ...story.workflow_state,
          ai_generations: {
            ...story.workflow_state?.ai_generations,
            final_video_config: videoConfig,
          },
        },
        updated_at: new Date().toISOString(),
      })
      .eq('id', storyId)
      .eq('uid', uid);

    if (updateError) {
      console.error('Failed to update story:', updateError);
      throw new Error('Failed to save video configuration');
    }

    // Save to workflow data table
    const { error: dataError } = await supabase
      .from('story_workflow_data')
      .upsert({
        story_id: storyId,
        data_type: 'final_video_config',
        data: {
          mulmoscript,
          videoConfig,
        },
        updated_at: new Date().toISOString(),
      });

    if (dataError) {
      console.error('Failed to save workflow data:', dataError);
    }

    // Create video record
    const { data: videoData, error: videoError } = await supabase
      .from('videos')
      .insert({
        story_id: storyId,
        uid,
        status: 'queued',
      })
      .select()
      .single();

    if (videoError) {
      console.error('Failed to create video record:', videoError);
      throw new Error('Failed to queue video generation');
    }

    // Call webhook for video generation
    const webhookPayload = {
      type: 'video_generation',
      payload: {
        video_id: videoData.id,
        story_id: storyId,
        uid: uid,
        title: story.title,
        script_json: mulmoscript
      }
    };

    // Check if webhook is disabled
    const disableWebhook = process.env.DISABLE_WEBHOOK === 'true';
    
    if (!disableWebhook) {
      try {
        // In development, use localhost
        const webhookUrl = process.env.NODE_ENV === 'development'
          ? 'http://localhost:8080/webhook'
          : process.env.WEBHOOK_URL || 'https://showgeki2-auto-process-mqku5oexhq-an.a.run.app/webhook';

        console.log(`üì° Calling webhook for video generation: ${webhookUrl}`);

        // Áü≠„ÅÑ„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åß webhook „ÇíÂëº„Å≥Âá∫„Åó
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5Áßí„Åß„Çø„Ç§„É†„Ç¢„Ç¶„Éà
        
        const webhookResponse = await fetch(webhookUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(webhookPayload),
          signal: controller.signal,
        });
        
        clearTimeout(timeoutId);

        if (!webhookResponse.ok) {
          const errorText = await webhookResponse.text();
          console.error('Webhook error:', webhookResponse.status, errorText);
          
          // Update video status to failed
          await supabase
            .from('videos')
            .update({
              status: 'failed',
              error_msg: `Webhook error: ${webhookResponse.status}`
            })
            .eq('id', videoData.id)
            .eq('uid', uid);
            
          throw new Error(`Webhook failed: ${webhookResponse.status}`);
        }

        console.log('‚úÖ Webhook called successfully for video generation');
      } catch (webhookError) {
        console.error('Failed to call webhook:', webhookError);
        
        // „Çø„Ç§„É†„Ç¢„Ç¶„Éà„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÅØÂãïÁîªÁîüÊàêÈñãÂßã„Å®„Åó„Å¶Êâ±„ÅÜ
        if (webhookError instanceof Error && webhookError.name === 'AbortError') {
          console.log('‚è∞ Webhook timeout - video generation started but response not waited');
          // „Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÅØÊ≠£Â∏∏„Å®„Åø„Å™„Åó„ÄÅ„Ç®„É©„Éº„Å´„Åó„Å™„ÅÑ
        } else {
          // „Åù„ÅÆ‰ªñ„ÅÆ„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÅØfailed„Çπ„ÉÜ„Éº„Çø„Çπ„Å´Êõ¥Êñ∞
          await supabase
            .from('videos')
            .update({
              status: 'failed',
              error_msg: `Webhook error: ${webhookError instanceof Error ? webhookError.message : 'Unknown error'}`
            })
            .eq('id', videoData.id)
            .eq('uid', uid);
            
          throw new Error('Failed to start video generation');
        }
      }
    } else {
      console.log('‚ö†Ô∏è Webhook is disabled. Video generation will not start automatically.');
    }

    return NextResponse.json({
      success: true,
      video: videoData,
      mulmoscript,
      message: disableWebhook ? 'Video record created but webhook disabled' : 'Video generation started - check videos page for progress'
    });
  } catch (error: any) {
    console.error('Generate final video error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to generate video' },
      { status: 500 }
    );
  }
}