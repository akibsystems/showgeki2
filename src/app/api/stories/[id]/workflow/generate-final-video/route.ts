import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase';
import { authMiddleware, type AuthResult } from '@/lib/auth';
import { StorySchema, VideoSchema, validateSchema, type Story, type Mulmoscript } from '@/lib/schemas';
import { ErrorType } from '@/types';

// ================================================================
// Route Parameters Type
// ================================================================

interface RouteContext {
  params: Promise<{ id: string }>;
}

// ================================================================
// Types
// ================================================================

interface VideoConfig {
  scenes: any[];
  characters: any[];
  audioSettings: any;
  bgmSettings: any;
  subtitleSettings: any;
}

// ================================================================
// Helper Functions
// ================================================================

function isValidStoryId(id: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return typeof id === 'string' && uuidRegex.test(id);
}

async function getStoryWithAuth(storyId: string, uid: string) {
  const supabase = createAdminClient();

  const { data, error } = await supabase
    .from('stories')
    .select('*')
    .eq('id', storyId)
    .eq('uid', uid)
    .single();

  if (error || !data) {
    throw new Error('Story not found');
  }

  return data;
}

/**
 * WorkflowデータからMulmoScript形式に変換
 */
function convertToMulmoscript(story: Story, videoConfig: VideoConfig): Mulmoscript {
  const { scenes, characters, audioSettings, bgmSettings, subtitleSettings } = videoConfig;

  // スピーカー情報の構築
  const speakers: Record<string, any> = {};
  characters.forEach((char: any) => {
    speakers[char.id] = {
      voiceId: char.voiceId,
      displayName: {
        ja: char.name,
        en: char.name,
      },
    };
  });

  // ビート（シーン）の構築
  const beats = scenes.map((scene: any) => ({
    id: scene.sceneId,
    speaker: scene.speaker,
    text: scene.dialogue,
    description: scene.title,
    imagePrompt: scene.imagePrompt,
    image: scene.customImageUrl ? {
      type: 'image' as const,
      source: {
        kind: 'url' as const,
        url: scene.customImageUrl,
      },
    } : undefined,
  }));

  // BGM設定の構築
  const bgmUrl = bgmSettings.find((bgm: any) => bgm.bgmId !== 'bgm_none')?.url;

  return {
    $mulmocast: {
      version: '1.0',
      credit: 'closing',
    },
    title: story.title,
    description: `Generated by ScriptDirector V2`,
    lang: 'ja',
    canvasSize: {
      width: 1280,
      height: 720,
    },
    speechParams: {
      provider: 'openai',
      speakers,
    },
    imageParams: {
      provider: 'openai',
      style: 'anime soft pastel colors',
      quality: process.env.OPENAI_IMAGE_QUALITY_DEFAULT || 'medium',
    },
    audioParams: {
      padding: 0.3,
      introPadding: 1.0,
      closingPadding: 0.8,
      outroPadding: 1.0,
      bgmVolume: audioSettings.masterBGMVolume || 0.2,
      audioVolume: audioSettings.audioVolume || 1.0,
      bgm: bgmUrl ? {
        kind: 'url',
        url: bgmUrl,
      } : undefined,
    },
    captionParams: subtitleSettings.enableSubtitles ? {
      lang: subtitleSettings.subtitleLanguage || 'ja',
      styles: [],
    } : undefined,
    beats,
  };
}

// ================================================================
// POST /api/stories/[id]/workflow/generate-final-video
// ================================================================

export async function POST(
  request: NextRequest,
  context: RouteContext
): Promise<NextResponse> {
  const { id: storyId } = await context.params;

  // Validate story ID
  if (!isValidStoryId(storyId)) {
    return NextResponse.json(
      { error: 'Invalid story ID format' },
      { status: 400 }
    );
  }

  // Authenticate request
  const authResult = await authMiddleware(request);
  if (!authResult.success) {
    return NextResponse.json(
      { error: authResult.error || 'Authentication failed' },
      { status: 401 }
    );
  }

  const uid = authResult.uid!;

  try {
    // Get request body
    const body = await request.json();
    const videoConfig: VideoConfig = body;

    if (!videoConfig.scenes || !videoConfig.characters) {
      return NextResponse.json(
        { error: 'Video configuration is incomplete' },
        { status: 400 }
      );
    }

    // Get story with ownership check
    const story = await getStoryWithAuth(storyId, uid);

    // Convert to MulmoScript format
    const mulmoscript = convertToMulmoscript(story, videoConfig);

    // Update story with final script
    const supabase = createAdminClient();
    const { error: updateError } = await supabase
      .from('stories')
      .update({
        script_json: mulmoscript,
        status: 'script_generated',
        workflow_state: {
          ...story.workflow_state,
          ai_generations: {
            ...story.workflow_state?.ai_generations,
            final_video_config: videoConfig,
          },
        },
        updated_at: new Date().toISOString(),
      })
      .eq('id', storyId)
      .eq('uid', uid);

    if (updateError) {
      console.error('Failed to update story:', updateError);
      throw new Error('Failed to save video configuration');
    }

    // Save to workflow data table
    const { error: dataError } = await supabase
      .from('story_workflow_data')
      .upsert({
        story_id: storyId,
        data_type: 'final_video_config',
        data: {
          mulmoscript,
          videoConfig,
        },
        updated_at: new Date().toISOString(),
      });

    if (dataError) {
      console.error('Failed to save workflow data:', dataError);
    }

    // Create video record
    const { data: videoData, error: videoError } = await supabase
      .from('videos')
      .insert({
        story_id: storyId,
        uid,
        status: 'queued',
      })
      .select()
      .single();

    if (videoError) {
      console.error('Failed to create video record:', videoError);
      throw new Error('Failed to queue video generation');
    }

    // Note: Actual video generation is handled by webhook-handler.js
    // which is triggered by database changes

    return NextResponse.json({
      success: true,
      video: videoData,
      mulmoscript,
    });
  } catch (error: any) {
    console.error('Generate final video error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to generate video' },
      { status: 500 }
    );
  }
}